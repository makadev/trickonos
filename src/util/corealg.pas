{   Unit with core algorithms.

    Copyright (C) 2011-2012  Matthias Karbe

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License along
    with this program; see COPYING.txt.
    if not, see <http://www.gnu.org/licenses/> or
    write to the Free Software Foundation, Inc.,
    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
}

{DOC>> This unit contains core algorithms}

unit corealg;

{$mode objfpc}{$H+}

interface

uses SysUtils, commontl;

{DOC>> permutation using the gf(2^16) polynom 0x10001111010011001, 
       called MAS3, adding Length and padded 16bit chunks of buffer, 
       multiplying it by 3 (MAS3 finite Field arithmetic). @br @br
       
       MAS3HASH is used for scrambling (permutation), its hashing
       capatibilitys are (mostly) untested, 
       thought up til now it performs quite well (in collisions).
       @br @br

       All Positions and Chars contribute to the final Number. 
       The value calculated, may be 4 or 8 byte (32/64bit).
       Hashes are shuffled and rotated in such a way, that bits are well
       distributed near MSB for both, long and short strings. 
       This is important for the THashTrie (coreobj). Otherwise
       (a lot of 0 near MSB) will create critical bits mostly near
       LSB and probably near MSB for longer strings, which creates
       longer lookup pathes for shorter strings. @br @br

       MAS3 was autogenerated (tested and selected from all primes below
       2^16) and was not taken from any Documentation, 
       Code and/or other Source.}
function mas3hash( const buf; len: MachineInt ): MachineWord; inline;
function mas3hash_len0: MachineWord; inline;

implementation

{$MACRO ON}

{$IF SizeOf(MachineWord) = 4}
  {check for Ror intrinsic (32bit)}
  {$IF DECLARED(RorDWord)}
    {$DEFINE rotate_right := RorDWord}
  {$ENDIF}
{$ELSEIF SizeOf(MachineWord) = 8}
  {check for Ror intrinsic (64bit)}
  {$IF DECLARED(RorDWord)}
    {$DEFINE rotate_right := RorQWord}
  {$ENDIF}
{$ENDIF}

{no ror intrinsic -> do it pure}
{$IF NOT DEFINED(rotate_right)}
function rotate_right( val: MachineWord; rval: Byte ): MachineWord; inline;
begin
  ASSERT(rval < SizeOf(MachineWord)*8);
  Result := (val shr MachineWord(rval)) or
            (val shl MachineWord(SizeOf(MachineWord)*8 - rval));
end;
{$ENDIF}

function mas3hash( const buf; len: MachineInt ): MachineWord;
{possibly worst hash... simple permutation using a gf(2^16) poly and
 multiplication with 3 (x^1+1) and 2 byte from the string
 in said polynom bound ring}
const
  msb16 = 1 shl 15;
  rpoly = { (reduced poly) $1E99 = x^12+x^11+x^10+x^9+x^7+x^4+x^3+1}
          1 or (1 shl 3) or (1 shl 4) or (1 shl 7) or
          (1 shl 9) or (1 shl 10) or (1 shl 11) or (1 shl 12);

var
  bufp: PByte;
  gf: MachineWord;
  i: MachineInt;

  procedure gf16_mul03; inline;
  begin
{$PUSH}
{$R-}
    if ( gf and msb16 ) > 0 then
      gf := ( gf shl 1 ) xor rpoly xor gf
    else
      gf := ( gf shl 1 ) xor gf;
{$POP}
  end;

begin
  bufp := PByte(@Buf);
  {add length}
  Result := 0;
  i := 1;
  if len > 1 then
    begin
      {permute and add 1..Length-(Length mod 2) with position}
      repeat
        gf := MachineWord(PWord(bufp)^);
{$PUSH}
{$R-}
        gf16_mul03;
        Result := rotate_right((Result xor MachineWord(i)) xor MachineWord(gf),16);
{$POP}
        Inc(i,2);
        Inc(bufp,2);
      until i >= len;
    end;
  {add last char if (Length mod 2)>0}
  if i = len then
    begin
      gf := MachineWord(Ord(bufp^));
{$PUSH}
{$R-}
      gf16_mul03;
      Result := rotate_right((Result xor MachineWord(i)) xor MachineWord(gf),16);
{$POP}
    end;
  {permute again, makes it look more hashy}
  for i := 0 to 7 do
    begin
      gf := Result;
{$PUSH}
{$R-}
      gf16_mul03;
      Result := rotate_right(Result xor MachineWord(gf),16);
{$POP}
    end;
end;

var
  mas3hash_len0_val: MachineWord;

function mas3hash_len0: MachineWord;
begin
  Result := mas3hash_len0_val;
end;


initialization
  mas3hash_len0_val := 0;
  mas3hash_len0_val := mas3hash(mas3hash_len0_val,0); // dummy var, not accessed in algorithm

end.

